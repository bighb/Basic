正课：
1. ***RegExp
2. ***String中支持正则的API:
    split、search、match、replace
3. *Math
4. *Date

1. ***RegExp对象：封装了正则表达式，提供了利用正则表达式执行验证和查找的API。
   何时使用：只要利用正则表达式执行验证和查找功能时

   创建：2种：
   1. var reg=/正则表达式/ig;
   何时使用：正则表达式在运行时不会改变
   2. var reg=new RegExp("正则表达式","ig");
   何时使用：在运行时正则表达式可能被改变时
   强调：所有\都要改为\\
      var str1="\\d{6}";
      var str2="\\d{15}(\\d\\d[0-9xX])?";
      var reg=new RegExp(str2,"");
      
   如何使用：2种操作：
   1. 格式验证：var bool=reg.test(str)
                验证str的格式是否符合reg的要求
      验证：要求从头到尾必须完整匹配！
      问题：test方法默认只要部分匹配即可！
      解决：都要在正则表达式前加^，后加$
            ^表示开头位置的xxxx
            $表示结尾位置的xxxx
            ^和$联用表示从头到尾必须完整匹配

   密码强度要求：6密码，只能是字母，数字的组合
                 至少包含一位大写字母，
                 至少包含一位数字
       预判：1. 不全由小写字母或数字组成
                   可能包含大写或符号
             (?![a-z0-9]*$)
             2. 不全由大写字母或小写字母组成
                   可能包含数字或符号
             (?![a-zA-Z]*$)
       正式规则：只能是字母数字的组合-->屏蔽了符号
             [a-zA-Z0-9]{6}
       完整：(?![a-z0-9]*$)(?![a-zA-Z]*$)[a-zA-Z0-9]{6}

   2. 查找API：
      var arr=reg.exec(str)：在str中查找所有符合reg规定的关键字
      要加g
      其中:arr[0]:保存了当前关键字的内容
           arr.index:保存了当前关键字的位置
           reg.lastIndex:保存下次开始查找的位置
  何时使用：只要即查找内容，又查找位置，只能用reg.exec

   总结：查找关键字：
    1. var i=str.search(reg)-->判断有没有  
	缺点：不能指定开始位置  
    2. var arr=str.match(reg)-->获得所有关键字内容，个数
	缺点：不能返回位置   
    3. var i=str.indexOf("kword"[,starti])
	-->从指定位置开始，查找下一个关键字的位置
        缺点：不支持正则
    4. var arr=reg.exec(str)-->即获得内容，又获得位置
	缺点：复杂

    正则：贪婪模式与懒惰模式
    默认贪婪模式：默认总是匹配最长的符合条件的字符串
       原因：.*或.+等引起
    懒惰模式：仅匹配最短的符合条件的字符串
       贪婪-->懒惰: (.*?)

    从正则表达式匹配结果中获取子内容：2步：
    1. 正则表达式中：用()包括要获取子内容的部分
    2. 程序中,本次查找后: RegExp.$n
		取*本次*匹配结果中第n个()匹配的子内容
                正则中n从1开始
    
2. ***String中的模式匹配API：4个
    2个查找：str.search(reg)  str.match(reg)
    1个替换：str.replace(reg);
    1个切割：









